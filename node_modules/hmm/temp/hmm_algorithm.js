'use strict';

var HMMAlgorithm = function(a, b, pi) {
  this.stateTransitionMatrix = a;
  this.observationProbabilityMatrix = b;
  this.initialStateDistributionMatrix = pi;

  this.numberOfStates = a.length;
  this.numberOfObservationSymbols = pi.length;
};

// This is the solution 1 in chapter 4.1, solved with (15)
HMMAlgorithm.prototype.getProbabilityOfObservations = function(o) {
  var n = this.numberOfStates;
  var T = o.length;

  var alphaPassResult = this._alphaPass(o);
  var c = alphaPassResult.c;

  var logProb = 0;
  for (var t = 1; t < T; t++) {
    logProb += Math.log(c[t]);
  }

  return Math.exp( - logProb);
};

// This is the solution 2 in chapter 4.2
HMMAlgorithm.prototype.getOptimalStateSequencesOfObservations = function(o) {

};

// This is the dynamic programming version of solution 2. See chapter 5.
HMMAlgorithm.prototype.getMostProbableStateSequencesOfObservations =
function(o) {
  var n = this.numberOfStates;
  var a = this.stateTransitionMatrix;
  var b = this.observationProbabilityMatrix;
  var pi = this.initialStateDistributionMatrix;
  var T = o.length;

  // Should be an UInt array and find the length from |n|
  var pathPointers = new Array((T - 1) * n);

  var delta = new Float64Array(T * n);
  for (var i = 0; i < n; i++) {
    delta[0 * n + i] = Math.log(pi[0][i] * b[i][o[0]]);
  }

  for (var t = 1; t < T; t++) {
    for (var i = 0; i < n; i++) {
      delta[t * n + i] = -Infinity;
      for (var j = 0; j < n; j++) {
        var s =
          delta[(t - 1) * n + j] + Math.log(a[i][j]) + Math.log(b[i][o[t]]);
        if (delta[t * n + i] < s) {
          delta[t * n + i] = s;
          pathPointers[(t - 1) * n + i] = j;
        }
      }
    }
  }

  var score = -Infinity;
  var stateSequences = new Array(T);

  for (var i = 0; i < n; i++) {
    if (score < delta[(T - 1) * n + i]) {
      score = delta[(T - 1) * n + i];
      stateSequences[T - 1] = i;
    }
  }

  var t = T - 1;
  var currentState = stateSequences[T - 1];
  while (t--) {
    currentState = stateSequences[t] = pathPointers[t * n + currentState];
  }

  return stateSequences;
};

// This is the solution 3 in chapter 4.3
HMMAlgorithm.prototype.trainWithObservations = function(o, maxIters) {

};

// This is the 2nd part of chapter 7: The Î±-pass
HMMAlgorithm.prototype._alphaPass = function(o) {
  var n = this.numberOfStates;
  var a = this.stateTransitionMatrix;
  var b = this.observationProbabilityMatrix;
  var pi = this.initialStateDistributionMatrix;

  var c = new Float64Array(T);
  var alpha = new Float64Array(T * n);

  c[0] = 0;
  for (var i = 0; i < n; i++) {
    alpha[0 * n + i] = pi[0][i] * b[i][o[0]];

    c[0] += alpha[0 * n + i];
  }

  c[0] = 1 / c[0];
  for (var i = 0; i < n; i++) {
    alpha[0 * n + i] *= c[0];
  }

  for (var t = 1; t < T; t++) {
    c[t] = 0;
    for (var i = 0; i < n; i++) {
      alpha[t * n + i] = 0;
      for (var j = 0; j < n; j++) {
        alpha[t * n + i] +=
          alpha[(t - 1) * n + j] * a[j][i];
      }
      alpha[t * n + i] *= b[i][o[t]];
      c[t] += alpha[t * n + i];
    }

    c[t] = 1 / c[t];
    for (var i = 0; i < n; i++) {
      alpha[t * n + i] *= c[t];
    }
  }

  return {
    c: c,
    alpha: alpha
  };
};

module.exports = HMMAlgorithm;
